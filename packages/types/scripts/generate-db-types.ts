#!/usr/bin/env tsx

/**
 * Script to generate TypeScript types from database schemas
 * This script analyzes Drizzle schema files and generates corresponding types
 */

import { readFileSync, readdirSync, statSync, writeFileSync } from 'fs';
import { extname, join } from 'path';

interface DatabaseTable {
  name: string;
  columns: DatabaseColumn[];
  relations?: DatabaseRelation[];
}

interface DatabaseColumn {
  name: string;
  type: string;
  nullable: boolean;
  primaryKey: boolean;
  foreignKey?: string;
  defaultValue?: string;
}

interface DatabaseRelation {
  name: string;
  type: 'one' | 'many';
  table: string;
  foreignKey: string;
}

/**
 * Generates TypeScript types for database schemas
 */
export class DatabaseTypeGenerator {
  private tables: DatabaseTable[] = [];

  /**
   * Analyzes Drizzle schema files and extracts table information
   */
  async analyzeSchemas(schemaDir: string): Promise<void> {
    const files = this.getSchemaFiles(schemaDir);
    
    for (const file of files) {
      try {
        const content = readFileSync(file, 'utf-8');
        const tables = this.parseSchema(content);
        this.tables.push(...tables);
      } catch (error) {
        console.error(`Error analyzing schema ${file}:`, error);
      }
    }
  }

  /**
   * Gets all schema files from directory
   */
  private getSchemaFiles(dir: string): string[] {
    const files: string[] = [];
    
    try {
      const items = readdirSync(dir);
      
      for (const item of items) {
        const fullPath = join(dir, item);
        const stat = statSync(fullPath);
        
        if (stat.isDirectory()) {
          files.push(...this.getSchemaFiles(fullPath));
        } else if (extname(item) === '.ts' && !item.includes('.test.') && !item.includes('.spec.')) {
          files.push(fullPath);
        }
      }
    } catch (error) {
      console.error(`Error reading directory ${dir}:`, error);
    }
    
    return files;
  }

  /**
   * Parses a schema file and extracts table information
   */
  private parseSchema(content: string): DatabaseTable[] {
    const tables: DatabaseTable[] = [];

    // Simple regex-based parsing for Drizzle schemas
    const tableRegex = /export const (\w+) = (?:pgTable|mysqlTable|sqliteTable)\(['"`](\w+)['"`],\s*{([^}]+)}/g;
    
    let match;
    while ((match = tableRegex.exec(content)) !== null) {
      const [, tableName, dbTableName, columnsStr] = match;
      const columns = this.parseColumns(columnsStr);
      
      tables.push({
        name: tableName,
        columns,
      });
    }

    return tables;
  }

  /**
   * Parses column definitions from table schema
   */
  private parseColumns(columnsStr: string): DatabaseColumn[] {
    const columns: DatabaseColumn[] = [];
    
    // Simple parsing - could be enhanced
    const columnRegex = /(\w+):\s*(\w+)\([^)]*\)(?:\.(\w+)\([^)]*\))*/g;
    
    let match;
    while ((match = columnRegex.exec(columnsStr)) !== null) {
      const [, name, type, modifier] = match;
      
      columns.push({
        name,
        type: this.mapDrizzleType(type),
        nullable: !modifier?.includes('notNull'),
        primaryKey: modifier?.includes('primaryKey') || false,
      });
    }

    return columns;
  }

  /**
   * Maps Drizzle types to TypeScript types
   */
  private mapDrizzleType(drizzleType: string): string {
    const typeMap: Record<string, string> = {
      'text': 'string',
      'varchar': 'string',
      'char': 'string',
      'integer': 'number',
      'int': 'number',
      'bigint': 'number',
      'decimal': 'number',
      'numeric': 'number',
      'real': 'number',
      'double': 'number',
      'boolean': 'boolean',
      'date': 'Date',
      'timestamp': 'Date',
      'time': 'string',
      'json': 'any',
      'jsonb': 'any',
      'uuid': 'string',
    };

    return typeMap[drizzleType.toLowerCase()] || 'unknown';
  }

  /**
   * Generates TypeScript interface definitions
   */
  generateTypes(): string {
    let output = `// Auto-generated database types
// Generated on: ${new Date().toISOString()}
// Do not edit this file manually

`;

    for (const table of this.tables) {
      const interfaceName = this.toPascalCase(table.name);
      
      // Generate base interface
      output += `export interface ${interfaceName} {\n`;
      for (const column of table.columns) {
        const optional = column.nullable ? '?' : '';
        output += `  ${column.name}${optional}: ${column.type};\n`;
      }
      output += `}\n\n`;

      // Generate insert type (without auto-generated fields)
      const insertColumns = table.columns.filter(col => 
        !col.primaryKey || col.name !== 'id'
      );
      
      if (insertColumns.length > 0) {
        output += `export interface ${interfaceName}Insert {\n`;
        for (const column of insertColumns) {
          const optional = column.nullable || column.defaultValue ? '?' : '';
          output += `  ${column.name}${optional}: ${column.type};\n`;
        }
        output += `}\n\n`;
      }

      // Generate update type (all fields optional except id)
      output += `export interface ${interfaceName}Update {\n`;
      for (const column of table.columns) {
        if (column.name !== 'id') {
          output += `  ${column.name}?: ${column.type};\n`;
        }
      }
      output += `}\n\n`;
    }

    // Generate union types
    output += `// Union types for all tables\n`;
    output += `export type DatabaseTables = {\n`;
    for (const table of this.tables) {
      const interfaceName = this.toPascalCase(table.name);
      output += `  ${table.name}: ${interfaceName};\n`;
    }
    output += `};\n\n`;

    return output;
  }

  /**
   * Converts snake_case to PascalCase
   */
  private toPascalCase(str: string): string {
    return str
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join('');
  }

  /**
   * Writes generated types to file
   */
  async writeTypes(outputPath: string): Promise<void> {
    const types = this.generateTypes();
    writeFileSync(outputPath, types, 'utf-8');
    console.log(`Generated database types written to: ${outputPath}`);
  }
}

/**
 * Main execution function
 */
async function main() {
  const generator = new DatabaseTypeGenerator();
  
  // Define schema directory (adjust as needed)
  const schemaDir = '../../apps/api/src/infrastructure/database/schema';

  try {
    await generator.analyzeSchemas(schemaDir);
    await generator.writeTypes(join(__dirname, '../src/database/generated.ts'));
    console.log('Database type generation completed successfully!');
  } catch (error) {
    console.error('Error generating database types:', error);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  main();
}

export { DatabaseTypeGenerator };
