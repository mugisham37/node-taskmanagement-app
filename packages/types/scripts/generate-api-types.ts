#!/usr/bin/env tsx

/**
 * Script to generate TypeScript types from API endpoints
 * This script analyzes tRPC routers and generates corresponding types
 */

import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';

interface ApiEndpoint {
  name: string;
  method: 'query' | 'mutation';
  input?: string;
  output?: string;
  description?: string;
}

interface ApiRouter {
  name: string;
  endpoints: ApiEndpoint[];
}

/**
 * Generates TypeScript types for API endpoints
 */
export class ApiTypeGenerator {
  private routers: ApiRouter[] = [];

  /**
   * Analyzes tRPC router files and extracts endpoint information
   */
  async analyzeRouters(routerPaths: string[]): Promise<void> {
    for (const routerPath of routerPaths) {
      try {
        const content = readFileSync(routerPath, 'utf-8');
        const router = this.parseRouter(content, routerPath);
        if (router) {
          this.routers.push(router);
        }
      } catch (error) {
        console.error(`Error analyzing router ${routerPath}:`, error);
      }
    }
  }

  /**
   * Parses a router file and extracts endpoint information
   */
  private parseRouter(content: string, filePath: string): ApiRouter | null {
    const routerName = this.extractRouterName(filePath);
    const endpoints: ApiEndpoint[] = [];

    // Simple regex-based parsing (could be enhanced with AST parsing)
    const queryRegex = /\.query\(['"`](\w+)['"`],\s*{([^}]+)}/g;
    const mutationRegex = /\.mutation\(['"`](\w+)['"`],\s*{([^}]+)}/g;

    let match;

    // Extract queries
    while ((match = queryRegex.exec(content)) !== null) {
      const [, name, body] = match;
      endpoints.push({
        name,
        method: 'query',
        ...this.parseEndpointBody(body),
      });
    }

    // Extract mutations
    while ((match = mutationRegex.exec(content)) !== null) {
      const [, name, body] = match;
      endpoints.push({
        name,
        method: 'mutation',
        ...this.parseEndpointBody(body),
      });
    }

    return endpoints.length > 0 ? { name: routerName, endpoints } : null;
  }

  /**
   * Extracts router name from file path
   */
  private extractRouterName(filePath: string): string {
    const fileName = filePath.split('/').pop() || '';
    return fileName.replace(/\.(ts|js)$/, '').replace(/[-_]router$/, '');
  }

  /**
   * Parses endpoint body to extract input/output types
   */
  private parseEndpointBody(body: string): Partial<ApiEndpoint> {
    const result: Partial<ApiEndpoint> = {};

    // Extract input schema
    const inputMatch = body.match(/input:\s*(\w+)/);
    if (inputMatch) {
      result.input = inputMatch[1];
    }

    // Extract output type (simplified)
    const outputMatch = body.match(/output:\s*(\w+)/);
    if (outputMatch) {
      result.output = outputMatch[1];
    }

    return result;
  }

  /**
   * Generates TypeScript interface definitions
   */
  generateTypes(): string {
    let output = `// Auto-generated API types
// Generated on: ${new Date().toISOString()}
// Do not edit this file manually

`;

    for (const router of this.routers) {
      output += `// ${router.name} Router Types\n`;
      output += `export namespace ${this.capitalize(router.name)}Api {\n`;

      for (const endpoint of router.endpoints) {
        const endpointName = this.capitalize(endpoint.name);
        
        if (endpoint.input) {
          output += `  export type ${endpointName}Input = ${endpoint.input};\n`;
        }
        
        if (endpoint.output) {
          output += `  export type ${endpointName}Output = ${endpoint.output};\n`;
        }

        output += `  export interface ${endpointName}Endpoint {\n`;
        output += `    method: '${endpoint.method}';\n`;
        if (endpoint.input) {
          output += `    input: ${endpointName}Input;\n`;
        }
        if (endpoint.output) {
          output += `    output: ${endpointName}Output;\n`;
        }
        output += `  }\n\n`;
      }

      output += `}\n\n`;
    }

    return output;
  }

  /**
   * Capitalizes the first letter of a string
   */
  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  /**
   * Writes generated types to file
   */
  async writeTypes(outputPath: string): Promise<void> {
    const types = this.generateTypes();
    writeFileSync(outputPath, types, 'utf-8');
    console.log(`Generated API types written to: ${outputPath}`);
  }
}

/**
 * Main execution function
 */
async function main() {
  const generator = new ApiTypeGenerator();
  
  // Define router paths (adjust as needed)
  const routerPaths = [
    '../../apps/api/src/trpc/router.ts',
    '../../apps/api/src/api/auth.ts',
    '../../apps/api/src/api/tasks.ts',
    '../../apps/api/src/api/projects.ts',
    '../../apps/api/src/api/users.ts',
  ];

  try {
    await generator.analyzeRouters(routerPaths);
    await generator.writeTypes(join(__dirname, '../src/api/generated.ts'));
    console.log('API type generation completed successfully!');
  } catch (error) {
    console.error('Error generating API types:', error);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  main();
}

export { ApiTypeGenerator };
