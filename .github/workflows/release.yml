name: Release Management

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.2.3)'
        required: true
      release_type:
        description: 'Type of release'
        required: true
        default: 'minor'
        type: choice
        options:
          - major
          - minor
          - patch
          - prerelease
      prerelease:
        description: 'Mark as pre-release'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '18'
  PNPM_VERSION: '8'

jobs:
  # Validate release
  validate:
    name: Validate Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Determine version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
            IS_PRERELEASE="${{ github.event.inputs.prerelease }}"
          else
            VERSION="${{ github.ref_name }}"
            # Check if version contains pre-release identifiers
            if [[ "$VERSION" =~ -[a-zA-Z] ]]; then
              IS_PRERELEASE="true"
            else
              IS_PRERELEASE="false"
            fi
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          echo "Release version: $VERSION (prerelease: $IS_PRERELEASE)"

      - name: Validate version format
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
            echo "Invalid version format: $VERSION"
            echo "Expected format: v1.2.3 or v1.2.3-alpha.1"
            exit 1
          fi

      - name: Check if tag exists
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          if git tag -l | grep -q "^$VERSION$"; then
            echo "Tag $VERSION already exists"
            exit 1
          fi

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run tests
        run: |
          pnpm run test:unit
          pnpm run lint
          pnpm run type-check

      - name: Build all applications
        run: |
          pnpm run build --filter=@taskmanagement/api
          pnpm run build --filter=@taskmanagement/web
          pnpm run build --filter=@taskmanagement/admin

  # Generate changelog
  changelog:
    name: Generate Changelog
    runs-on: ubuntu-latest
    needs: validate
    outputs:
      changelog: ${{ steps.changelog.outputs.changelog }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Generate changelog
        id: changelog
        run: |
          # Get the previous tag
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          CURRENT_VERSION="${{ needs.validate.outputs.version }}"
          
          echo "Generating changelog from $PREVIOUS_TAG to $CURRENT_VERSION"
          
          # Generate changelog using conventional commits
          if [ -n "$PREVIOUS_TAG" ]; then
            COMMITS=$(git log --pretty=format:"- %s (%h)" $PREVIOUS_TAG..HEAD)
          else
            COMMITS=$(git log --pretty=format:"- %s (%h)")
          fi
          
          # Categorize commits
          FEATURES=$(echo "$COMMITS" | grep -E "^- feat" || true)
          FIXES=$(echo "$COMMITS" | grep -E "^- fix" || true)
          BREAKING=$(echo "$COMMITS" | grep -E "^- feat.*!:|^- fix.*!:" || true)
          DOCS=$(echo "$COMMITS" | grep -E "^- docs" || true)
          CHORES=$(echo "$COMMITS" | grep -E "^- chore|^- ci|^- build" || true)
          
          # Build changelog
          CHANGELOG="# Release $CURRENT_VERSION\n\n"
          
          if [ -n "$BREAKING" ]; then
            CHANGELOG="${CHANGELOG}## ðŸš¨ Breaking Changes\n\n$BREAKING\n\n"
          fi
          
          if [ -n "$FEATURES" ]; then
            CHANGELOG="${CHANGELOG}## âœ¨ New Features\n\n$FEATURES\n\n"
          fi
          
          if [ -n "$FIXES" ]; then
            CHANGELOG="${CHANGELOG}## ðŸ› Bug Fixes\n\n$FIXES\n\n"
          fi
          
          if [ -n "$DOCS" ]; then
            CHANGELOG="${CHANGELOG}## ðŸ“š Documentation\n\n$DOCS\n\n"
          fi
          
          if [ -n "$CHORES" ]; then
            CHANGELOG="${CHANGELOG}## ðŸ”§ Maintenance\n\n$CHORES\n\n"
          fi
          
          # Add deployment information
          CHANGELOG="${CHANGELOG}## ðŸš€ Deployment Information\n\n"
          CHANGELOG="${CHANGELOG}- **Docker Images**: Available at \`ghcr.io/${{ github.repository }}\`\n"
          CHANGELOG="${CHANGELOG}- **API Version**: $CURRENT_VERSION\n"
          CHANGELOG="${CHANGELOG}- **Web App**: Compatible with this API version\n"
          CHANGELOG="${CHANGELOG}- **Admin Dashboard**: Compatible with this API version\n"
          CHANGELOG="${CHANGELOG}- **Mobile App**: Compatible with this API version\n\n"
          
          # Add migration notes if needed
          if [ -n "$BREAKING" ]; then
            CHANGELOG="${CHANGELOG}## ðŸ“‹ Migration Notes\n\n"
            CHANGELOG="${CHANGELOG}This release contains breaking changes. Please review the changes above and update your integration accordingly.\n\n"
          fi
          
          # Save changelog to file
          echo -e "$CHANGELOG" > RELEASE_CHANGELOG.md
          
          # Output for GitHub Actions (escape newlines)
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo -e "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload changelog
        uses: actions/upload-artifact@v3
        with:
          name: changelog
          path: RELEASE_CHANGELOG.md

  # Build release artifacts
  build-artifacts:
    name: Build Release Artifacts
    runs-on: ubuntu-latest
    needs: validate
    strategy:
      matrix:
        app: [api, web, admin]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build application
        run: |
          pnpm run build --filter=@taskmanagement/${{ matrix.app }}
        env:
          NODE_ENV: production
          BUILD_VERSION: ${{ needs.validate.outputs.version }}

      - name: Create release archive
        run: |
          cd apps/${{ matrix.app }}
          
          # Create archive with build artifacts
          if [ "${{ matrix.app }}" = "api" ]; then
            tar -czf ../../${{ matrix.app }}-${{ needs.validate.outputs.version }}.tar.gz \
              dist/ package.json
          else
            tar -czf ../../${{ matrix.app }}-${{ needs.validate.outputs.version }}.tar.gz \
              .next/ package.json public/
          fi

      - name: Generate checksums
        run: |
          sha256sum ${{ matrix.app }}-${{ needs.validate.outputs.version }}.tar.gz > \
            ${{ matrix.app }}-${{ needs.validate.outputs.version }}.tar.gz.sha256

      - name: Upload release artifacts
        uses: actions/upload-artifact@v3
        with:
          name: release-artifacts-${{ matrix.app }}
          path: |
            ${{ matrix.app }}-${{ needs.validate.outputs.version }}.tar.gz
            ${{ matrix.app }}-${{ needs.validate.outputs.version }}.tar.gz.sha256

  # Build and push Docker images
  build-docker:
    name: Build Release Docker Images
    runs-on: ubuntu-latest
    needs: validate
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        app: [api, web, admin]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to Docker Hub
        if: secrets.DOCKERHUB_USERNAME != ''
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ghcr.io/${{ github.repository }}/${{ matrix.app }}
            ${{ secrets.DOCKERHUB_USERNAME != '' && format('taskmanagement/{0}', matrix.app) || '' }}
          tags: |
            type=semver,pattern={{version}},value=${{ needs.validate.outputs.version }}
            type=semver,pattern={{major}}.{{minor}},value=${{ needs.validate.outputs.version }}
            type=semver,pattern={{major}},value=${{ needs.validate.outputs.version }}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: apps/${{ matrix.app }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64,linux/arm64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
            BUILD_VERSION=${{ needs.validate.outputs.version }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}

  # Create GitHub release
  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [validate, changelog, build-artifacts, build-docker]
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v3

      - name: Create Git tag
        if: github.event_name == 'workflow_dispatch'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a ${{ needs.validate.outputs.version }} -m "Release ${{ needs.validate.outputs.version }}"
          git push origin ${{ needs.validate.outputs.version }}

      - name: Create GitHub Release
        uses: actions/create-release@v1
        id: create_release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.validate.outputs.version }}
          release_name: Release ${{ needs.validate.outputs.version }}
          body: ${{ needs.changelog.outputs.changelog }}
          draft: false
          prerelease: ${{ needs.validate.outputs.is_prerelease }}

      - name: Upload API artifacts
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: release-artifacts-api/api-${{ needs.validate.outputs.version }}.tar.gz
          asset_name: api-${{ needs.validate.outputs.version }}.tar.gz
          asset_content_type: application/gzip

      - name: Upload API checksum
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: release-artifacts-api/api-${{ needs.validate.outputs.version }}.tar.gz.sha256
          asset_name: api-${{ needs.validate.outputs.version }}.tar.gz.sha256
          asset_content_type: text/plain

      - name: Upload Web artifacts
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: release-artifacts-web/web-${{ needs.validate.outputs.version }}.tar.gz
          asset_name: web-${{ needs.validate.outputs.version }}.tar.gz
          asset_content_type: application/gzip

      - name: Upload Web checksum
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: release-artifacts-web/web-${{ needs.validate.outputs.version }}.tar.gz.sha256
          asset_name: web-${{ needs.validate.outputs.version }}.tar.gz.sha256
          asset_content_type: text/plain

      - name: Upload Admin artifacts
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: release-artifacts-admin/admin-${{ needs.validate.outputs.version }}.tar.gz
          asset_name: admin-${{ needs.validate.outputs.version }}.tar.gz
          asset_content_type: application/gzip

      - name: Upload Admin checksum
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: release-artifacts-admin/admin-${{ needs.validate.outputs.version }}.tar.gz.sha256
          asset_name: admin-${{ needs.validate.outputs.version }}.tar.gz.sha256
          asset_content_type: text/plain

  # Deploy to production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [validate, create-release]
    if: needs.validate.outputs.is_prerelease == 'false'
    environment:
      name: production
      url: https://taskmanagement.app
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Deploy to production
        run: |
          export KUBECONFIG=kubeconfig
          VERSION="${{ needs.validate.outputs.version }}"
          
          # Update deployment images
          kubectl set image deployment/taskmanagement-api \
            api=ghcr.io/${{ github.repository }}/api:$VERSION -n production
          kubectl set image deployment/taskmanagement-web \
            web=ghcr.io/${{ github.repository }}/web:$VERSION -n production
          kubectl set image deployment/taskmanagement-admin \
            admin=ghcr.io/${{ github.repository }}/admin:$VERSION -n production
          
          # Wait for rollout to complete
          kubectl rollout status deployment/taskmanagement-api -n production --timeout=600s
          kubectl rollout status deployment/taskmanagement-web -n production --timeout=600s
          kubectl rollout status deployment/taskmanagement-admin -n production --timeout=600s

      - name: Verify deployment
        run: |
          # Test production endpoints
          curl -f https://api.taskmanagement.app/health
          curl -f https://taskmanagement.app
          curl -f https://admin.taskmanagement.app
          
          echo "Production deployment verified successfully!"

  # Update documentation
  update-docs:
    name: Update Documentation
    runs-on: ubuntu-latest
    needs: [validate, create-release]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update version in documentation
        run: |
          VERSION="${{ needs.validate.outputs.version }}"
          
          # Update README.md with new version
          sed -i "s/Version: v[0-9]\+\.[0-9]\+\.[0-9]\+/Version: $VERSION/g" README.md
          
          # Update API documentation
          if [ -f docs/api/openapi.yaml ]; then
            sed -i "s/version: '[0-9]\+\.[0-9]\+\.[0-9]\+'/version: '${VERSION#v}'/g" docs/api/openapi.yaml
          fi
          
          # Update package.json versions
          find . -name "package.json" -not -path "./node_modules/*" | while read file; do
            sed -i "s/\"version\": \"[0-9]\+\.[0-9]\+\.[0-9]\+\"/\"version\": \"${VERSION#v}\"/g" "$file"
          done

      - name: Commit version updates
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "chore: update version to ${{ needs.validate.outputs.version }}" || exit 0
          git push

  # Notification
  notify-release:
    name: Notify Release
    runs-on: ubuntu-latest
    needs: [validate, create-release, deploy-production, update-docs]
    if: always()
    steps:
      - name: Notify successful release
        if: needs.create-release.result == 'success'
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#releases'
          text: |
            ðŸŽ‰ New release published: ${{ needs.validate.outputs.version }}!
            
            ðŸ“¦ **Release Details:**
            - Version: ${{ needs.validate.outputs.version }}
            - Type: ${{ needs.validate.outputs.is_prerelease == 'true' && 'Pre-release' || 'Stable Release' }}
            - Docker Images: Available at `ghcr.io/${{ github.repository }}`
            
            ðŸš€ **Deployment Status:**
            - Production: ${{ needs.deploy-production.result || 'skipped (pre-release)' }}
            - Documentation: ${{ needs.update-docs.result }}
            
            ðŸ“‹ **Links:**
            - [Release Notes](https://github.com/${{ github.repository }}/releases/tag/${{ needs.validate.outputs.version }})
            - [Docker Images](https://github.com/${{ github.repository }}/pkgs/container)
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify failed release
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: '#releases'
          text: |
            ðŸš¨ Release ${{ needs.validate.outputs.version }} failed!
            
            Failed steps:
            - Validation: ${{ needs.validate.result }}
            - Changelog: ${{ needs.changelog.result }}
            - Build Artifacts: ${{ needs.build-artifacts.result }}
            - Build Docker: ${{ needs.build-docker.result }}
            - Create Release: ${{ needs.create-release.result }}
            - Deploy Production: ${{ needs.deploy-production.result }}
            - Update Docs: ${{ needs.update-docs.result }}
            
            Please check the workflow logs and retry the release.
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}